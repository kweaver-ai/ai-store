# 单页应用改造成 qiankun 微应用完整指南

本文档详细说明如何将现有的单页应用（SPA）改造成 qiankun 微应用，包含代码改造和部署配置的完整流程。

## 目录

1. [概述](#概述)
2. [前置条件](#前置条件)
3. [步骤 1：单页应用改造成 qiankun 微应用](#步骤-1单页应用改造成-qiankun-微应用)
4. [步骤 2：配置 Nginx、Dockerfile、Charts](#步骤-2配置-nginxdockerfilecharts)
5. [测试验证](#测试验证)
6. [常见问题](#常见问题)

---

## 概述

将单页应用改造成 qiankun 微应用需要完成两个主要步骤：

1. **代码改造**：修改应用代码，使其支持 qiankun 生命周期和主应用通信
2. **部署配置**：配置 Nginx、Dockerfile 和 K8s Charts，使应用能够正确部署和访问

改造的核心是：

- **导出生命周期函数**：`bootstrap`、`mount`、`unmount`
- **适配路由系统**：使用主应用提供的 `basename`
- **集成全局状态**：使用主应用提供的状态管理 API
- **处理认证信息**：使用主应用传递的 token 和用户信息
- **配置部署环境**：Nginx、Dockerfile、K8s Charts

---

## 前置条件

### 1. 技术栈要求

- React 16.8+（支持 Hooks）
- 支持 UMD 格式导出（webpack/vite 等构建工具配置）
- 路由库：React Router v6（推荐）或 v5

### 2. 主应用提供的 Props

微应用会收到以下 props（类型定义见下方）：

```typescript
interface MicroAppProps {
  // 认证相关
  token: {
    get accessToken(): string
    refreshToken: () => Promise<{ accessToken: string }>
    onTokenExpired?: (code?: number) => void
  }
  
  // 路由信息
  route: {
    basename: string  // 应用路由基础路径，如 "dip-hub/application/123"
  }
  
  // 用户信息
  user: {
    id: string
    get vision_name(): string
    get account(): string
  }
  
  // 应用信息
  application: {
    id: number
    name: string
    icon: string
  }
  
  // UI 组件渲染函数
  renderAppMenu: (container: HTMLElement | string) => void
  
  // 用户操作
  logout: () => void
  
  // 全局状态管理
  setMicroAppState: (state: Record<string, any>) => boolean
  onMicroAppStateChange: (
    callback: (state: any, prev: any) => void,
    fireImmediately?: boolean
  ) => () => void
  
  // 容器 DOM 元素
  container: HTMLElement
}
```

---

## 步骤 1：单页应用改造成 qiankun 微应用

### 步骤 1.1：安装依赖

如果项目还没有安装 `qiankun`，需要安装：

```bash
npm install qiankun
# 或
yarn add qiankun
```

**注意**：微应用只需要安装 `qiankun` 用于类型定义，不需要调用 `start()` 等方法。

---

### 步骤 1.2：环境适配与准备

根据使用的构建工具（Webpack 或 Vite），适配方式有所不同。

#### 1.2.1 Webpack 项目：创建 `public-path.js`

在 `src` 目录下创建 `public-path.js`，用于动态设置 webpack 的 `publicPath`：

```javascript
// src/public-path.js
if (window.__POWERED_BY_QIANKUN__) {
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ || '/'
}
```

在应用入口文件（如 `src/index.tsx` 或 `src/main.tsx`）的**最顶部**引入：

```typescript
// src/index.tsx
import './public-path'  // 必须在最顶部引入

import React from 'react'
import ReactDOM from 'react-dom/client'
// ... 其他导入
```

#### 1.2.2 Vite 项目：适配说明

Vite 项目**不需要** `public-path.js`。它是通过 `vite-plugin-qiankun` 插件来处理路径和生命周期的。

1. **安装插件**：
   ```bash
   npm install vite-plugin-qiankun
   ```
2. **入口文件适配**：详见步骤 1.3。

---

### 步骤 1.3：修改入口文件，导出生命周期函数

#### 1.3.1 改造前（独立运行）

```typescript
// src/index.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import packageJson from '../package.json'

// 使用 package.json 的 name 作为根元素 id，避免与其他微应用冲突
const rootId = `${packageJson.name}-root`

const root = ReactDOM.createRoot(document.getElementById(rootId)!)
root.render(<App />)
```

#### 1.3.2 改造后（支持 qiankun）

##### Webpack 项目

```typescript
// src/index.tsx
import './public-path'  // 必须在最顶部

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import packageJson from '../package.json'

// 使用 package.json 的 name 作为根元素 id，避免与其他微应用冲突
const rootId = `${packageJson.name}-root`

// 定义渲染函数
let root: ReactDOM.Root | null = null

function render(props?: any) {
  const { container, basename } = props || {}
  // 优先查找基于 package name 的 id，如果没有则使用 container 或 fallback 到 #root
  const rootElement = container 
    ? container.querySelector(`#${rootId}`) || container.querySelector('#root') || container 
    : document.querySelector(`#${rootId}`) || document.querySelector('#root')
  
  if (!rootElement) {
    console.error(`找不到根元素 #${rootId} 或 #root`)
    return
  }

  root = ReactDOM.createRoot(rootElement)
  root.render(<App basename={basename} />)
}

// 独立运行
if (!window.__POWERED_BY_QIANKUN__) {
  render()
}

// 导出生命周期函数
export async function bootstrap() {
  console.log('[微应用] bootstrap')
}

export async function mount(props: any) {
  console.log('[微应用] mount', props)
  render(props)
}

export async function unmount(props: any) {
  console.log('[微应用] unmount', props)
  if (root) {
    root.unmount()
    root = null
  }
}
```

##### Vite 项目

Vite 项目需要使用 `vite-plugin-qiankun` 提供的辅助函数。

```typescript
// src/main.tsx (Vite 通常使用 main.tsx)
import React from 'react'
import ReactDOM from 'react-dom/client'
import { renderWithQiankun, qiankunWindow } from 'vite-plugin-qiankun/dist/helper'
import App from './App'

let root: ReactDOM.Root | null = null

function render(props?: any) {
  const { container, route } = props || {}
  const basename = route?.basename || '/'
  
  const rootElement = container 
    ? container.querySelector('#root') || container 
    : document.querySelector('#root')
  
  if (!rootElement) {
    console.error('找不到根元素')
    return
  }

  if (root) {
    root.unmount()
  }

  root = ReactDOM.createRoot(rootElement)
  root.render(<App basename={basename} />)
}

// 使用插件提供的 renderWithQiankun 导出生命周期
renderWithQiankun({
  mount(props) {
    console.log('[微应用] mount', props)
    render(props)
  },
  bootstrap() {
    console.log('[微应用] bootstrap')
  },
  unmount(props: any) {
    console.log('[微应用] unmount')
    if (root) {
      root.unmount()
      root = null
    }
  },
  update(props: any) {
    console.log('[微应用] update', props)
  }
})

// 独立运行判断
if (!qiankunWindow.__POWERED_BY_QIANKUN__) {
  render()
}
```

**关键点**：
- `bootstrap`：微应用启动时调用，可以在这里做一些初始化工作
- `mount`：微应用挂载时调用，在这里渲染应用
- `unmount`：微应用卸载时调用，在这里清理资源
- **Webpack**：通过直接 `export` 生命周期函数实现，需要 `public-path.js`。
- **Vite**：通过 `renderWithQiankun` 注册生命周期，判断环境使用 `qiankunWindow.__POWERED_BY_QIANKUN__`。
- **根元素 ID**：使用 `package.json` 的 `name` 字段生成唯一的根元素 id（如 `${packageName}-root`），避免多个微应用之间的冲突
- **HTML 模板**：确保 HTML 模板中的根元素 id 与代码中的 `rootId` 一致，例如：
  ```html
  <!-- public/index.html 或 index.html -->
  <div id="my-micro-app-root"></div>
  ```

---

### 步骤 1.4：改造路由系统

#### 1.4.1 接收 basename

从 props 中获取 `basename`，并传递给路由系统。

#### 1.4.2 React Router v6 示例

```typescript
// src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom'

interface AppProps {
  basename?: string
}

const App = ({ basename = '/' }: AppProps) => {
  return (
    <BrowserRouter basename={basename}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        {/* 其他路由 */}
      </Routes>
    </BrowserRouter>
  )
}

export default App
```

#### 1.4.3 React Router v5 示例

```typescript
// src/App.tsx
import { BrowserRouter, Route, Switch } from 'react-router-dom'

interface AppProps {
  basename?: string
}

const App = ({ basename = '/' }: AppProps) => {
  return (
    <BrowserRouter basename={basename}>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        {/* 其他路由 */}
      </Switch>
    </BrowserRouter>
  )
}

export default App
```

**重要**：
- `basename` 由主应用提供，格式如 `/application/123`
- 微应用内部路由应该使用相对路径，如 `/`、`/about`，而不是绝对路径
- 最终访问路径 = `basename` + 微应用内部路径

---

### 步骤 1.5：集成全局状态管理

主应用提供了全局状态管理 API，微应用可以：

- **设置状态**：更新面包屑等允许的字段
- **监听状态**：监听语言切换等全局状态变化

#### 1.5.1 在 App 组件中接收 props

```typescript
// src/App.tsx
import { useEffect } from 'react'
import { BrowserRouter } from 'react-router-dom'

interface AppProps {
  basename?: string
  setMicroAppState?: (state: Record<string, any>) => boolean
  onMicroAppStateChange?: (
    callback: (state: any, prev: any) => void,
    fireImmediately?: boolean
  ) => () => void
  application?: {
    id: number
    name: string
    icon: string
  }
}

const App = ({ 
  basename = '/',
  setMicroAppState,
  onMicroAppStateChange,
  application
}: AppProps) => {
  // 监听全局状态变化（如语言切换）
  useEffect(() => {
    if (!onMicroAppStateChange) return

    const unsubscribe = onMicroAppStateChange((state, prev) => {
      console.log('全局状态变化:', state, prev)
      // 处理语言切换等
      if (state.language !== prev.language) {
        // 更新应用语言
        // i18n.changeLanguage(state.language)
      }
    }, true) // fireImmediately: true 表示立即触发一次

    return () => {
      unsubscribe()
    }
  }, [onMicroAppStateChange])

  // 更新面包屑示例
  const updateBreadcrumb = () => {
    if (setMicroAppState) {
      setMicroAppState({
        breadcrumb: [
          { name: '首页', path: '/' },
          { name: '当前页面', path: '/current' }
        ]
      })
    }
  }

  // 访问应用信息示例（在微应用加载时确定，不会在运行时变化）
  if (application) {
    const appId = application.id
    const appName = application.name
    const appIcon = application.icon
    console.log('应用信息:', { appId, appName, appIcon })
  }

  return (
    <BrowserRouter basename={basename}>
      {/* 应用内容 */}
    </BrowserRouter>
  )
}
```

#### 1.5.2 允许更新的字段

微应用只能更新以下字段：
- `breadcrumb`：面包屑导航数据

其他字段（如 `language`）只能由主应用更新，微应用只能监听。

---

### 步骤 1.6：集成认证信息

#### 1.6.1 接收 token 和用户信息

```typescript
// src/App.tsx
interface AppProps {
  basename?: string
  token?: {
    get accessToken(): string
    refreshToken: () => Promise<{ accessToken: string }>
    onTokenExpired?: (code?: number) => void
  }
  user?: {
    id: string
    get vision_name(): string
    get account(): string
  }
}

const App = ({ basename, token, user }: AppProps) => {
  // 使用 token
  useEffect(() => {
    if (token) {
      // 设置 HTTP 请求的 token
      // axios.defaults.headers.common['Authorization'] = `Bearer ${token.accessToken}`
      
      // 监听 token 过期
      if (token.onTokenExpired) {
        // 在 HTTP 拦截器中调用
      }
    }
  }, [token])

  return (
    <BrowserRouter basename={basename}>
      {/* 应用内容 */}
    </BrowserRouter>
  )
}
```

#### 1.6.2 配置 HTTP 客户端

如果使用 axios，可以这样配置：

```typescript
// src/utils/http.ts
import axios from 'axios'

let tokenGetter: (() => string) | null = null
let tokenRefreshFn: (() => Promise<{ accessToken: string }>) | null = null
let tokenExpiredHandler: ((code?: number) => void) | null = null

export function setupHttpClient(props: {
  token: {
    get accessToken(): string
    refreshToken: () => Promise<{ accessToken: string }>
    onTokenExpired?: (code?: number) => void
  }
}) {
  tokenGetter = () => props.token.accessToken
  tokenRefreshFn = props.token.refreshToken
  tokenExpiredHandler = props.token.onTokenExpired || null

  // 配置请求拦截器
  axios.interceptors.request.use((config) => {
    if (tokenGetter) {
      config.headers.Authorization = `Bearer ${tokenGetter()}`
    }
    return config
  })

  // 配置响应拦截器
  axios.interceptors.response.use(
    (response) => response,
    async (error) => {
      if (error.response?.status === 401 && tokenExpiredHandler) {
        // Token 过期，通知主应用
        tokenExpiredHandler(error.response?.status)
      }
      return Promise.reject(error)
    }
  )
}
```

在 App 组件中调用：

```typescript
import { setupHttpClient } from './utils/http'

const App = ({ basename, token, user }: AppProps) => {
  useEffect(() => {
    if (token) {
      setupHttpClient({ token })
    }
  }, [token])

  // ...
}
```

---

### 步骤 1.7：配置构建工具

#### 1.7.1 Webpack 配置

需要配置 `output` 支持 UMD 格式，这是 qiankun 微应用的关键配置：

```javascript
// webpack.config.js
const path = require('path')
const packageName = require('./package.json').name

module.exports = {
  entry: './src/index.tsx',
  output: {
    // 公共路径，用于资源加载
    publicPath: './',
    // 输出目录
    path: path.resolve(__dirname, 'dist'),
    // 输出文件名，使用 contenthash 实现长期缓存
    filename: '[name].[contenthash:8].js',
    // 构建前清理输出目录
    clean: true,
    // 必须声明为 umd 格式，qiankun 需要此格式才能加载微应用
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    // Webpack 5 使用 chunkLoadingGlobal，Webpack 4 使用 jsonpFunction
    // 避免多个微应用之间的全局变量冲突
    chunkLoadingGlobal: `webpackJsonp_${packageName}`,
  },
  // 开发服务器配置（支持跨域）
  devServer: {
    port: 3000,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',
      'Access-Control-Allow-Headers': 'X-Requested-With, content-type, Authorization',
    },
  },
  // 其他配置...
}
```

**关键配置说明**：
- `library` 和 `libraryTarget: 'umd'`：必须配置，使微应用以 UMD 格式导出，qiankun 才能加载
- `chunkLoadingGlobal`：为每个微应用设置唯一的全局变量名，避免多个微应用之间的冲突
- `devServer.headers`：开发环境必须配置跨域头，允许主应用加载微应用资源

#### 1.7.2 Vite 配置

如果使用 Vite，需要配置：

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: '/',
  build: {
    rollupOptions: {
      output: {
        format: 'umd',
        name: 'micro-app',
      },
    },
  },
  server: {
    port: 8081,
    cors: true, // 允许跨域
    headers: {
      'Access-Control-Allow-Origin': '*',
    },
  },
})
```

#### 1.7.3 开发服务器配置

开发服务器需要支持跨域：

**Webpack Dev Server**:
```javascript
// webpack.config.js
module.exports = {
  devServer: {
    headers: {
      'Access-Control-Allow-Origin': '*',
    },
  },
}
```

**Vite Dev Server**:
已在上面配置中设置。

---

### 步骤 1.8：样式隔离

qiankun 使用 `experimentalStyleIsolation` 进行样式隔离，会自动为微应用的样式添加作用域。

**注意事项**：
- 避免使用全局样式选择器（如 `* { }`）
- 避免修改 `body`、`html` 等全局元素的样式
- 使用 CSS Modules 或 styled-components 等方案可以更好地避免样式冲突

---

### 步骤 1.9：处理其他主应用功能

#### 1.9.1 使用 renderAppMenu

如果需要在微应用中渲染主应用提供的菜单组件：

```typescript
const App = ({ basename, renderAppMenu }: AppProps) => {
  useEffect(() => {
    if (renderAppMenu) {
      // 渲染到指定容器
      const menuContainer = document.getElementById('app-menu-container')
      if (menuContainer) {
        renderAppMenu(menuContainer)
      }
    }
  }, [renderAppMenu])

  return (
    <div>
      <div id="app-menu-container" />
      <BrowserRouter basename={basename}>
        {/* 应用内容 */}
      </BrowserRouter>
    </div>
  )
}
```

#### 1.9.2 使用 logout

```typescript
const App = ({ basename, logout }: AppProps) => {
  const handleLogout = () => {
    if (logout) {
      logout()
    }
  }

  return (
    <BrowserRouter basename={basename}>
      <button onClick={handleLogout}>退出登录</button>
      {/* 其他内容 */}
    </BrowserRouter>
  )
}
```

---

### 步骤 1.10：完整示例

#### 1.10.1 入口文件（index.tsx）

```typescript
// src/index.tsx
import './public-path'

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import type { MicroAppProps } from './types'
import packageJson from '../package.json'

// 使用 package.json 的 name 作为根元素 id，避免与其他微应用冲突
const rootId = `${packageJson.name}-root`

let root: ReactDOM.Root | null = null

function render(props?: { container?: HTMLElement; basename?: string }) {
  const { container, basename } = props || {}
  // 优先查找基于 package name 的 id，如果没有则使用 container 或 fallback 到 #root
  const rootElement = container 
    ? container.querySelector(`#${rootId}`) || container.querySelector('#root') || container 
    : document.querySelector(`#${rootId}`) || document.querySelector('#root')
  
  if (!rootElement) {
    console.error(`找不到根元素 #${rootId} 或 #root`)
    return
  }

  root = ReactDOM.createRoot(rootElement)
  root.render(<App {...props} />)
}

// 独立运行
if (!window.__POWERED_BY_QIANKUN__) {
  render()
}

// 导出生命周期函数
export async function bootstrap() {
  console.log('[微应用] bootstrap')
}

export async function mount(props: MicroAppProps) {
  console.log('[微应用] mount', props)
  render({
    container: props.container,
    basename: props.route?.basename,
  })
}

export async function unmount(props: MicroAppProps) {
  console.log('[微应用] unmount', props)
  if (root) {
    root.unmount()
    root = null
  }
}
```

#### 1.10.2 App 组件

```typescript
// src/App.tsx
import { useEffect } from 'react'
import { BrowserRouter } from 'react-router-dom'
import type { MicroAppProps } from './types'
import { setupHttpClient } from './utils/http'

const App = (props: Partial<MicroAppProps>) => {
  const {
    route,
    token,
    user,
    application,
    setMicroAppState,
    onMicroAppStateChange,
    renderAppMenu,
    logout,
  } = props

  const basename = route?.basename || '/'

  // 设置 HTTP 客户端
  useEffect(() => {
    if (token) {
      setupHttpClient({ token })
    }
  }, [token])

  // 监听全局状态变化
  useEffect(() => {
    if (!onMicroAppStateChange) return

    const unsubscribe = onMicroAppStateChange((state, prev) => {
      if (state.language !== prev.language) {
        // 处理语言切换
        console.log('语言切换:', state.language)
      }
    }, true)

    return unsubscribe
  }, [onMicroAppStateChange])

  // 渲染应用菜单
  useEffect(() => {
    if (renderAppMenu) {
      const menuContainer = document.getElementById('app-menu-container')
      if (menuContainer) {
        renderAppMenu(menuContainer)
      }
    }
  }, [renderAppMenu])

  return (
    <BrowserRouter basename={basename}>
      <div id="app-menu-container" />
      {/* 应用路由和内容 */}
    </BrowserRouter>
  )
}

export default App
```

#### 1.10.3 类型定义

```typescript
// src/types.ts
export interface MicroAppProps {
  token?: {
    get accessToken(): string
    refreshToken: () => Promise<{ accessToken: string }>
    onTokenExpired?: (code?: number) => void
  }
  route?: {
    basename: string
  }
  user?: {
    id: string
    get vision_name(): string
    get account(): string
  }
  application?: {
    id: number
    name: string
    icon: string
  }
  renderAppMenu?: (container: HTMLElement | string) => void
  logout?: () => void
  setMicroAppState?: (state: Record<string, any>) => boolean
  onMicroAppStateChange?: (
    callback: (state: any, prev: any) => void,
    fireImmediately?: boolean
  ) => () => void
  container?: HTMLElement
}
```

---

## 步骤 2：配置 Nginx、Dockerfile、Charts

完成代码改造后，需要配置部署相关的文件，使微应用能够正确部署和访问。

### 步骤 2.1：配置 Nginx

创建 `nginx.conf` 文件，配置微应用的访问路径和静态文件服务。

**标准 Nginx 配置示例**：

```nginx
server {
    # 监听端口（根据实际情况修改）
    listen 1101;
    listen [::]:1101;

    # 隐藏版本号（安全建议）
    server_tokens off;

    # 微应用的访问路径配置
    # 注意：location 后面的路径就是 entry 中的路径部分
    location /dip-frontend {
        # 静态文件缓存配置
        if ($request_filename ~* ^.*[.](html|htm)$) {
            expires 0;
            add_header Cache-Control "no-store";
        }

        if ($request_filename ~* ^.*[.](js|css|png|jpg|svg|ico)$) {
            add_header Cache-Control "public, max-age=2592000";
        }

        # 静态文件目录（构建后的 dist 目录）
        alias "/app/dist";
        index index.html;
        
        # 支持前端路由（重要：必须配置）
        try_files $uri $uri/ /dip-frontend/index.html;
    }

    # 健康检查端点（K8s 探针使用）
    location = /probe {
        return 200 "ok";
    }

    # 错误页面
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```

**配置说明**：

1. **`location /dip-frontend`**：
   - 这是微应用的访问路径
   - entry 应该配置为 `/dip-frontend/index.html`（相对于主应用 origin 的路径）
   - 可以根据实际情况修改，如 `/apps/my-app`、`/micro-apps/data-analysis` 等

2. **`alias "/app/dist"`**：
   - 指向构建后的静态文件目录
   - 通常构建产物在 `dist` 目录
   - 根据实际部署路径修改

3. **`try_files`**：
   - **重要**：必须配置，用于支持前端路由（React Router）
   - 格式：`try_files $uri $uri/ /路径/index.html;`
   - 路径必须与 `location` 后面的路径一致

4. **缓存配置**：
   - HTML 文件不缓存（`no-store`）
   - 静态资源（JS/CSS/图片）缓存 30 天
   - 根据实际需求调整

**修改路径的步骤**：

如果需要修改微应用的访问路径（例如从 `/dip-frontend` 改为 `/apps/my-app`）：

1. **修改 Nginx 配置**：
   ```nginx
   location /apps/my-app {  # ← 修改这里
       alias "/app/dist";
       index index.html;
       try_files $uri $uri/ /apps/my-app/index.html;  # ← 路径也要修改
   }
   ```

2. **同步修改 Dockerfile、Charts 和 entry 配置**（见下方步骤）

---

### 步骤 2.2：配置 Dockerfile

创建 `Dockerfile`，用于构建包含 Nginx 和静态文件的 Docker 镜像。

**标准 Dockerfile 配置示例**：

```dockerfile
FROM acr.aishu.cn/public/nginx:1.22.1-alpine-latest

# 给nginx添加权限
RUN chown root /usr/sbin/nginx && \
    chmod 757 -R /usr/sbin/nginx && \
    chmod u+s /usr/sbin/nginx && \
    chmod 777 -R /var/log/nginx/* && \
    sed -i "s@www-data@root@g" /etc/nginx/nginx.conf && \
    sed -i "s@error_log.*@error_log /dev/null;@g"  /etc/nginx/nginx.conf && \
    sed -i "s@access_log.*@access_log off;@g" /etc/nginx/nginx.conf && \
    sed -i "s@# server_tokens.*@server_tokens off;@g" /etc/nginx/nginx.conf

# 暴露端口（与 nginx.conf 中的 listen 端口一致）
EXPOSE 1101

# 复制 Nginx 配置文件
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 复制构建后的静态文件
COPY dist /app/dist
```

**配置说明**：

1. **基础镜像**：使用 Nginx 官方镜像或公司内部镜像
2. **权限配置**：根据实际需求配置 Nginx 权限
3. **端口**：`EXPOSE` 的端口必须与 `nginx.conf` 中的 `listen` 端口一致
4. **文件复制**：
   - `nginx.conf` → `/etc/nginx/conf.d/default.conf`
   - `dist` → `/app/dist`（与 nginx.conf 中的 `alias` 路径一致）

**构建和测试**：

```bash
# 构建镜像
docker build -t my-micro-app:latest .

# 测试运行
docker run -p 1101:1101 my-micro-app:latest

# 访问测试
curl http://localhost:1101/dip-frontend
```

---

### 步骤 2.3：配置 K8s Charts

如果使用 K8s 部署，需要配置 Helm Charts。

#### 2.3.1 配置 values.yaml

创建或修改 `charts/应用名称/values.yaml`：

```yaml
replicaCount: 1

namespace: dip
moduleName: dip-frontend

image:
  registry: acr.aishu.cn
  repository: /dip/dip-frontend
  tag: 3.0.0.5
  pullPolicy: IfNotPresent
  name: dip-frontend

service:
  ingressclassname: ''
  dipFrontend:
    type: ClusterIP
    port: 1101
    nodePort: 1101
    ingress:
      enabled: true
      interface:
        path:
          - /dip-frontend  # ← 这个路径必须与 nginx.conf 中的 location 路径一致
  enableDualStack: false
  type: ClusterIP
  ports:
    port1: 1101
    protocol1: TCP
    targetPort1: 1101
    name1: dip-frontend

resources:
  requests:
    cpu: 1
    memory: 1Gi
  limits:
    cpu: 11
    memory: 20Gi

probe:
  livenessProbe:
    httpGet:
      path: /probe
      port: 1101
    initialDelaySeconds: 25
    periodSeconds: 50
    timeoutSeconds: 20
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    httpGet:
      path: /probe
      port: 1101
    initialDelaySeconds: 10
    periodSeconds: 30
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  startupProbe:
    httpGet:
      path: /probe
      port: 1101
    initialDelaySeconds: 20
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
```

**关键配置说明**：

1. **`service.dipFrontend.ingress.interface.path`**：
   - 这是 Ingress 的路径配置
   - **必须与 nginx.conf 中的 `location` 路径一致**
   - 这个路径就是 entry 中的路径部分

2. **`service.dipFrontend.port`**：
   - 服务端口，必须与 nginx.conf 中的 `listen` 端口一致

3. **`probe`**：
   - 健康检查配置，使用 `/probe` 端点（在 nginx.conf 中已配置）

#### 2.3.2 检查其他 Chart 文件

确保以下文件配置正确：

- **`templates/deployment.yaml`**：使用 values.yaml 中的配置
- **`templates/service.yaml`**：端口配置与 values.yaml 一致
- **`templates/ingress.yaml`**：路径配置与 values.yaml 一致

---

### 步骤 2.4：配置 entry（name 和 entry）

**重要**：在主应用的后端系统中配置微应用时，需要填写 `name` 和 `entry` 两个字段。

#### 2.4.1 name（微应用名称）

**填写说明**：
- **推荐**：与微应用的 `package.json` 文件中的 `name` 字段保持一致
- **不强求**：如果无法获取 `package.json`，可以使用其他唯一标识符
- **格式要求**：建议使用小写字母、数字和连字符（kebab-case），如 `my-micro-app`、`data-analysis-app`
- **唯一性**：必须保证在整个系统中唯一，不能与其他微应用重复

**如何获取**：
1. 打开微应用项目的 `package.json` 文件
2. 找到 `"name"` 字段，复制其值

**示例**：
```json
// package.json
{
  "name": "my-micro-app"  // ← 使用这个值作为 name
}
```

#### 2.4.2 entry（微应用入口地址）

**填写说明**：
- **含义**：微应用的访问地址，主应用通过这个地址加载微应用
- **格式**：必须以 `/` 开头，相对于当前页面（主应用）的 origin 解析
- **不能包含路由**：entry 不能包含 `#` 符号和路由路径（如不能是 `/app#/home`）

**格式说明**：

entry 必须以 `/` 开头，是相对于当前页面 origin 的路径。主应用会根据当前页面的 origin（协议、域名、端口）来解析 entry 路径。

**如何确定路径**：

1. **查看 Nginx 配置**：
   - 打开项目的 `nginx.conf` 文件
   - 查找 `location` 配置块，如 `location /micro-app-test { ... }`
   - `location` 后面的路径就是 entry 的路径部分

2. **查看 K8s Ingress 配置**（如果使用 K8s 部署）：
   - 打开 `charts/应用名称/values.yaml` 文件
   - 查找 `service.dipFrontend.ingress.interface.path` 配置
   - 配置的路径就是 entry 的路径部分
   - **注意**：如果 Nginx 的 `location` 和 Ingress 的 `path` 不一致，以 Ingress 的 `path` 为准（因为外部访问会经过 Ingress）

**完整示例**：

假设 Nginx 配置为：
```nginx
location /micro-app-test {
    alias "/app/dist";
    try_files $uri $uri/ /micro-app-test/index.html;
}
```

K8s Ingress 配置为：
```yaml
service:
  dipFrontend:
    ingress:
      interface:
        path:
          - /micro-app-test
```

对应的 entry 配置：
```json
{
  "micro_app": {
    "name": "micro-app-test",
    "entry": "/micro-app-test/index.html"
    //        ↑
    //        └─ 路径：从 nginx.conf 的 location 或 values.yaml 的 ingress.path 获取，必须以 / 开头
  }
}
```

**说明**：
- entry `/micro-app-test/index.html` 会相对于主应用的 origin 解析
- 如果主应用在 `https://10.4.134.36`，则 entry 实际解析为 `https://10.4.134.36/micro-app-test/index.html`
- 路径部分必须与 Nginx 配置中的 `location` 路径一致（或与 K8s Ingress 的 `path` 一致）
- entry 应该指向能够访问到 `/路径/index.html` 的路径

**开发环境填写**：

开发环境如果微应用和主应用在不同端口，可以使用完整 URL：

- **示例**：
  - `/micro-app-test/index.html` （如果微应用和主应用在同一 origin）
  - `http://localhost:8081` （如果微应用在不同端口，需要完整 URL）

**注意事项**：
1. ✅ **正确示例**：
   - `/micro-app-test/index.html` （生产环境，相对于主应用 origin）
   - `/dip-frontend/index.html` （生产环境）
   - `http://localhost:8081` （开发环境，跨端口时需要完整 URL）

2. ❌ **错误示例**：
   - `/micro-app-test/index.html#/home` （不能包含 `#`）
   - `micro-app-test/index.html` （缺少开头的 `/`）
   - `https://10.4.134.36/micro-app-test/index.html` （生产环境不需要完整 URL，会相对于主应用 origin 解析）

---

### 步骤 2.5：配置检查清单

在配置完成后，请确认：

- [ ] Nginx 配置文件已创建，`location` 路径已配置
- [ ] Nginx 配置中的 `try_files` 已正确配置，支持前端路由
- [ ] Dockerfile 已创建，端口与 Nginx 配置一致
- [ ] Dockerfile 中的文件路径与 Nginx 配置一致
- [ ] K8s values.yaml 中的路径配置与 Nginx 配置一致
- [ ] K8s values.yaml 中的端口配置与 Nginx 配置一致
- [ ] `name` 字段已填写，且在整个系统中唯一
- [ ] `entry` 字段已填写，以 `/` 开头（相对于主应用 origin 的路径）
- [ ] `entry` 不包含 `#` 符号
- [ ] `entry` 中的路径与 Nginx 配置中的 `location` 路径一致
- [ ] `entry` 指向的路径可以正常访问（如 `/micro-app-test/index.html`）

---

## 测试验证

### 1. 独立运行测试

确保应用可以独立运行：

```bash
npm run dev
# 或
yarn dev
```

访问 `http://localhost:8081`，确认应用正常显示。

### 2. 在主应用中测试

1. 确保主应用已配置微应用的 entry 地址
2. 在主应用中访问微应用路由
3. 检查：
   - 微应用是否正确加载
   - 路由是否正常工作
   - 全局状态是否正常同步
   - 认证信息是否正常传递

### 3. 本地调试

主应用支持通过 localStorage 配置覆盖微应用的 entry URL，方便在开发环境下进行本地调试。

**使用方法**：

1. **在浏览器控制台设置**：
   ```javascript
   localStorage.setItem('DIP_HUB_LOCAL_DEV_MICRO_APPS', JSON.stringify({
     'your-micro-app-name': 'http://localhost:8081'
   }))
   ```

2. **或者通过浏览器开发者工具设置**：
   - 打开浏览器开发者工具（F12）
   - 切换到 `Application`（或 `存储`）标签
   - 选择 `Local Storage`
   - 添加 key：`DIP_HUB_LOCAL_DEV_MICRO_APPS`
   - 添加 value：`{"your-micro-app-name": "http://localhost:8081"}`

**配置说明**：

- **配置格式**：JSON 对象，key 为微应用名称（与后端配置的 `name` 字段一致），value 为本地 entry URL
- **支持多个微应用**：可以同时配置多个微应用的本地入口
- **示例**：
  ```javascript
  {
    "micro-app-name-1": "http://localhost:8081",
    "micro-app-name-2": "http://localhost:8082"
  }
  ```

**注意事项**：

- 设置完成后需要刷新主应用页面，配置才会生效
- 本地调试配置会覆盖后端配置的 entry URL
- 清除配置：`localStorage.removeItem('DIP_HUB_LOCAL_DEV_MICRO_APPS')` 或删除对应的 Local Storage 项

---

## 常见问题

### Q1: 微应用加载后白屏

**可能原因**：
1. 没有正确导出生命周期函数
2. `public-path.js` 没有在最顶部引入
3. 路由 basename 配置错误
4. 构建配置不正确

**解决方案**：
- 检查浏览器控制台错误信息
- Webpack 项目：检查 `window.__POWERED_BY_QIANKUN__` 是否为 `true`。
- Vite 项目：检查 `qiankunWindow.__POWERED_BY_QIANKUN__` 是否为 `true`。
- 确认访问 entry 的 URL 能否正常获得微应用的资源。

### Q2: 路由跳转不正确

**可能原因**：
- basename 没有正确传递给路由组件
- 使用了绝对路径而不是相对路径

**解决方案**：
- 确认 `basename` 已传递给 `BrowserRouter`
- 使用相对路径，如 `<Link to="/about">` 而不是 `<Link to="/app/about">`

### Q3: 样式冲突

**可能原因**：
- 使用了全局样式选择器
- 样式隔离未生效

**解决方案**：
- 使用 CSS Modules 或 styled-components
- 避免修改全局元素样式
- 检查 qiankun 的样式隔离配置

### Q4: Token 获取不到

**可能原因**：
- token 是 getter，需要调用 `token.accessToken` 而不是直接访问
- HTTP 拦截器配置不正确

**解决方案**：
- 使用 `token.accessToken` 获取 token（注意是函数调用）
- 检查 HTTP 拦截器配置

### Q5: 全局状态更新不生效

**可能原因**：
- 尝试更新不允许的字段
- 状态更新函数调用错误

**解决方案**：
- 确认只更新允许的字段（如 `breadcrumb`）
- 检查 `setMicroAppState` 返回值，`false` 表示更新失败

---

## 总结

改造单页应用为 qiankun 微应用的核心步骤：

1. ✅ 安装 qiankun 依赖
2. ✅ 创建 `public-path.js` 并在入口文件顶部引入
3. ✅ 导出生命周期函数（`bootstrap`、`mount`、`unmount`）
4. ✅ 改造路由系统，使用主应用提供的 `basename`
5. ✅ 集成全局状态管理 API
6. ✅ 集成认证信息（token、用户信息）
7. ✅ 配置构建工具支持 UMD 格式
8. ✅ 配置开发服务器支持跨域
9. ✅ 测试验证

完成以上步骤后，你的单页应用就可以作为 qiankun 微应用被主应用加载了。

---

## 参考资源

- [qiankun 官方文档](https://qiankun.umijs.org/)
