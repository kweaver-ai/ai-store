"""
Mock 应用适配器

用于本地开发和测试时模拟数据库操作。
"""
import logging
from typing import List, Optional
from datetime import datetime
from copy import deepcopy

from src.domains.application import Application
from src.ports.application_port import ApplicationPort

logger = logging.getLogger(__name__)


class MockApplicationAdapter(ApplicationPort):
    """
    Mock 应用适配器。

    使用内存存储模拟数据库操作。
    """

    def __init__(self):
        """初始化 Mock 适配器。"""
        self._applications = {}
        self._next_id = 1
        
        # 预置一些模拟数据
        self._add_sample_data()
        
        logger.info("Mock 应用适配器已初始化")

    def _add_sample_data(self):
        """添加示例数据。"""
        sample_apps = [
            Application(
                id=1,
                key="itops-analysis",
                name="智能故障分析",
                description="DIP for ITOps 运维大脑应用，提供智能故障诊断和根因分析能力",
                icon=None,
                version="1.0.0",
                category="DIP for ITOps",
                release_config=["itops-analysis-release"],
                ontology_ids=[1, 2],
                agent_ids=[1],
                is_config=True,
                updated_by="system",
                updated_at=datetime.now(),
            ),
            Application(
                id=2,
                key="security-monitor",
                name="安全监控助手",
                description="实时安全事件监控和威胁分析应用",
                icon=None,
                version="2.1.0",
                category="安全运营",
                release_config=["security-monitor-release"],
                ontology_ids=[],
                agent_ids=[],
                is_config=False,
                updated_by="system",
                updated_at=datetime.now(),
            ),
        ]
        
        for app in sample_apps:
            self._applications[app.key] = app
        
        self._next_id = len(sample_apps) + 1

    async def get_all_applications(self) -> List[Application]:
        """
        获取所有已安装的应用列表。

        返回:
            List[Application]: 应用列表
        """
        apps = list(self._applications.values())
        apps.sort(key=lambda x: x.updated_at or datetime.min, reverse=True)
        logger.info(f"[Mock] 获取应用列表: {len(apps)} 个应用")
        return apps

    async def get_application_by_key(self, key: str) -> Application:
        """
        根据应用唯一标识获取应用信息。

        参数:
            key: 应用包唯一标识

        返回:
            Application: 应用实体

        异常:
            ValueError: 当应用不存在时抛出
        """
        if key in self._applications:
            logger.info(f"[Mock] 获取应用: {key}")
            return deepcopy(self._applications[key])
        
        logger.warning(f"[Mock] 应用不存在: {key}")
        raise ValueError(f"应用不存在: {key}")

    async def get_application_by_key_optional(self, key: str) -> Optional[Application]:
        """
        根据应用唯一标识获取应用信息（可选）。

        参数:
            key: 应用包唯一标识

        返回:
            Optional[Application]: 应用实体，不存在时返回 None
        """
        if key in self._applications:
            return deepcopy(self._applications[key])
        return None

    async def create_application(self, application: Application) -> Application:
        """
        创建新应用。

        参数:
            application: 应用实体

        返回:
            Application: 创建后的应用实体（包含生成的 ID）

        异常:
            ValueError: 当应用 key 已存在时抛出
        """
        if application.key in self._applications:
            raise ValueError(f"应用已存在: {application.key}")
        
        application.id = self._next_id
        self._next_id += 1
        application.updated_at = application.updated_at or datetime.now()
        
        self._applications[application.key] = deepcopy(application)
        logger.info(f"[Mock] 创建应用: {application.key} (ID: {application.id})")
        
        return application

    async def update_application(self, application: Application) -> Application:
        """
        更新应用信息。

        参数:
            application: 应用实体

        返回:
            Application: 更新后的应用实体

        异常:
            ValueError: 当应用不存在时抛出
        """
        if application.key not in self._applications:
            raise ValueError(f"应用不存在: {application.key}")
        
        application.updated_at = application.updated_at or datetime.now()
        self._applications[application.key] = deepcopy(application)
        logger.info(f"[Mock] 更新应用: {application.key}")
        
        return application

    async def update_application_config(
        self,
        key: str,
        ontology_ids: List[int],
        agent_ids: List[int],
        updated_by: str
    ) -> Application:
        """
        更新应用配置（业务知识网络和智能体）。

        参数:
            key: 应用唯一标识
            ontology_ids: 业务知识网络 ID 列表
            agent_ids: 智能体 ID 列表
            updated_by: 更新者用户 ID

        返回:
            Application: 更新后的应用实体

        异常:
            ValueError: 当应用不存在时抛出
        """
        if key not in self._applications:
            raise ValueError(f"应用不存在: {key}")
        
        app = self._applications[key]
        app.ontology_ids = ontology_ids
        app.agent_ids = agent_ids
        app.is_config = True
        app.updated_by = updated_by
        app.updated_at = datetime.now()
        
        logger.info(f"[Mock] 更新应用配置: {key}, ontologies={ontology_ids}, agents={agent_ids}")
        
        return deepcopy(app)

    async def delete_application(self, key: str) -> bool:
        """
        删除应用。

        参数:
            key: 应用包唯一标识

        返回:
            bool: 是否删除成功

        异常:
            ValueError: 当应用不存在时抛出
        """
        if key not in self._applications:
            raise ValueError(f"应用不存在: {key}")
        
        del self._applications[key]
        logger.info(f"[Mock] 删除应用: {key}")
        
        return True

    async def close(self):
        """关闭适配器（Mock 不需要实际关闭操作）。"""
        logger.info("[Mock] 应用适配器已关闭")

